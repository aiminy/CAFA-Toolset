#!/usr/bin/env python

'''
    This program takes the following four inputs:
        (1) a UniProtKB/SwissProt file
        (2) a UniProt-GOA file
        (3) a taxon id
        (4) an optional output file

    When the output file name is NOT given, the program will construct 
    an output file name by combining the UniProtKB/SwissProt and 
    UniProt-GOA file names supplied by the user. 

    The GO terms in the UniProtKB/SwissProt file that are NOT in the
    UniProt-GOA file for the supplied taxon id, are merged together
    with those in the UniProt-GOA file and written to the output file.
'''

import os
import sys
from os.path import basename 

import argparse
#import configparser as cp
import ConfigParser as cp
import shutil
import subprocess
from collections import defaultdict

import AppendSprot2GOA as as2g
import Config
import ArgParser_Mergedb as ap
import FormatChecker as fc
import LocateDataset as ld

class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

config_filename = '.cafarc' # Default configuration file name

class Mergedb: 
    def __init__(self): 
        self.parsed_dict = ap.parse_args() # Collect user arguments into a dictionary
        self.ConfigParam = Config.read_config(config_filename) # Collect config file entries
        self.work_dir = self.ConfigParam['workdir']

        # Find workspace: 
        if not os.path.exists(self.work_dir):
            os.makedirs(self.work_dir) # Create work space, if it does not exist
        t1 = self.parsed_dict['t1']
        t2 = self.parsed_dict['t2']
        outfile_basename = basename(self.parsed_dict['outfile'])

        self.t1_input_file = ld.locate_SwissProtfile(t1,
                                                     self.work_dir) # Locate t1 file.
        self.t2_input_file = ld.locate_GOAfile(t2,
                                               self.work_dir) # Locate t2 file.
        self.output_filename = self.create_outfilename(self.parsed_dict,
                                                  outfile_basename,
                                                  self.work_dir) # Create output file name

    def create_iterator(self, infile):
        # Returns an iterator object for an input uniprot-goa file along 
        # with a list of all field names contained in the uniprot-goa file
        infile_handle = open(infile, 'r')
        iter_handle = GOA.gafiterator(infile_handle)
        for ingen in iter_handle:
            if len(ingen) == 17:
                GAFFIELDS = GOA.GAF20FIELDS
                break
            else:
                GAFFIELDS = GOA.GAF10FIELDS
                break
        infile_handle = open(infile, 'r')
        iter_handle = GOA.gafiterator(infile_handle)
        return iter_handle, GAFFIELDS

    def create_outfilename(self, params, outfile, work_dir):
         # Creates an output filename based on the output file prefix 
         # provided by the user:
        if not outfile == '':
            ob = basename(self.parsed_dict['outfile'])
        else:
            ob = basename(self.parsed_dict['t2']) + '+sprot.' + \
                          str(basename(self.parsed_dict['t1']).split('.')[-1])
        index = 1
        while os.path.exists(self.work_dir + '/' + ob + '.' + str(index)):
            index = index + 1
        output_filename = self.work_dir + '/' + ob + '.' + str(index)
        return output_filename

    def print_prolog(self):
        print "*************************************************"
        print "Welcome to Merge Database Tool !!!!!"
        print "*************************************************\n"
        print 'Following is a list of user supplied inputs:\n'
        for arg in self.parsed_dict:
            print arg + ': ' + str(self.parsed_dict[arg])
        print '*********************************************\n'
        return None

    def print_epilog(self):
        if os.path.exists(self.output_filename):
            print(bcolors.OKGREEN + 'The following output file is created: ' + \
                  basename(self.output_filename) + bcolors.ENDC)
        else:
            print(bcolors.WARNING + 'No output file is created with the given \
                  input parameters' + bcolors.ENDC)
        print(bcolors.OKGREEN + 'Thank you for using Merge Database Tool' + \
              bcolors.ENDC)
        return None

    def process_data(self): 
        # Print wellcome message:
        self.print_prolog() 
        # Check UniProt-GOA file format:
        fc.check_gaf_format(self.t2_input_file) 
        print ('Merging records: ')
        # Merge steps:
        # Step 1: 
           # Copy the gene association file to the output file:
        print ('Copying records from ' + \
                basename(self.t2_input_file) + ' to ' + \
                basename(self.output_filename) + ' ...')

        cmd = "cp " + self.t2_input_file + " " + self.output_filename 
        subprocess.call(cmd, shell=True)
        # Step 2: 
            # Fetch records from from Uniprot-SwissProt file
            # Check for duplicacy in UniProt-GOA file 
            # Convert them to GOA records
            # Append them at the end of the output file
        print ('Appedning records from ' + \
                basename(self.t1_input_file) + ' to ' + \
                basename(self.output_filename) + ' ...')

        as2g.appendSprot2goa(open(self.t1_input_file, 'r'), 
                             self.t2_input_file, 
                             self.parsed_dict['g'], 
                             open(self.output_filename, 'a'))

        # Print the summary of running this program:
        self.print_epilog()
        return None

if __name__ == '__main__': 
    if (sys.argv[0] == 'Mergedb' or sys.argv[0] == './Mergedb') and len(sys.argv) == 1:
        print (sys.argv[0] + ' docstring:')
        print(__doc__)
        sys.exit(0)
    else: 
        md = Mergedb()    # Creates an instance of Mergedb class
        md.process_data() # Process data and create merged file
        sys.exit(0)
